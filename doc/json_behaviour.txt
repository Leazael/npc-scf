preparation:
  Before parsing and mapping, all lines are concatenated (using the behaviour dictated by the concatenatros)
  Lines forming tables are joined if they are part of a table: i.e., containing a header and a row for each tableRowChar.

"tableRowChar":
  The tableRowChar object tells us which character will be used to define the rows of the table.
  It is used at the start of a line (skipping any whitespace). The resulting line will be added to the previous one for parsing.
  During parsing, the line is split on the character, and each "row" is cleaned up and used as an input, after further splitting it using the separators. 
  
"commentChar":
  All lines that start with this character, (after the removal of any leading whitespace), are not parsed.

"keywordChar"
  The characters that preface keywords. Relevant when the keywords themselves are added to the inputs.
  
"matchList":
  The "matchList" array is used to determine wether a given line matches the mapping.
  Each match of the array can be either a string, or an array of strings. 
  In the case that a match in the matchList is itself an array, such a match is interpreted as a logical "OR", meaning that either of the strings listed may be used. 
  Matching is done case-insensitively.
    
  In order for a line to match, it must start (after removing any leading whitespace) with the first match provided in the matchList. 
  (Possibly augmented by the keywordChar.)
  
  If the mapping that matches has "isTable" set to true, then the block must have multiple lines, some preceded by the tableRowChar.
  The rows are not further parsed, but are each conisdered to be a singular input to the mapped function.
  
  If mulitple mappings match, then the first one is chosen. (i.e., more specific environment-mappings, if placed first, will always supercede more generic environment-mappings placed later in the mappings array)
    
  A line matching a mapping with N matches is parsed as follows:
    The line is split into N segments, as defined by the matchList array, starting right of the first match and ending on the right of the last match.
    These segments are then cleaned (meaning any trailing/leading whitespace is removed).
    The remaining segments are then passed along as input to the command. 
    
"cmd":
  each "cmd" object in the JSON file must contain at least a "command", specifying which latex command will be used in the mapping.
  
  By default, we assume that a command has only a single input. 
  
  If the latex command has more than one input, the number must be specified in "nInputs" in the latex object.
  Note that by default the nInputs must equal the number of entries in the mappings match. (Unless "includeInputs", or "isTable" is used, see below)
  
OPTIONAL ITEMS: 

"passMatch": (Bool, default false)
  if passMatch is set to true, then the list of inputs is doubled, as the matches themselves are added to the input.
  Before doing so, they are stripped of the kewwordChar  

"includeInputs": (Array of Booleans)
  If the latex command takes fewer inputs than the number of matches, or if the text preceding the first match must be counted as input, one must define an "includeInputs" array of booleans. 
  The length of this array must be equal to the number of matches in the matchList
  The inputs corresponding to a true entry will be passed to the command, hence the number of trues must match the "nInputs" in the "cmd" object.
  Note that is passMatch is true, the array must be twice the length of the number of matches.
  
"isPadding" (Array of Strings)
  For the purpose of cleaning the input obtained from this mapping, characters, or strings defined in the "isPadding" array are treated as whitespace.
  
"isTable" 
  Wether the match is interpreted as a table. Everything starting at the "tableRowChar" is considered a separate input.
  
"separators"
  If the corresponding environment or keywords defines a table, one can define an array of separators.
  Separators can only be single (ascii) characters and indicate the positions at which the rows are split into columns.
  They are applied in the order given, similar to the matchList, however, the last character is repeated.
  
"Description"
  For the purpose of documentation, each mapping object may carry a "description".
  
  
  
    
    
